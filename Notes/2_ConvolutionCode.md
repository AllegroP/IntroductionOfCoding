## 卷积码

### 从分组码到卷积码

在上一节“线性码”中，我们讲述了如何增加冗余度，构造一个线性运算封闭的码集。从映射的角度讲，线性码是一种分组码，即将信息流分成长度一定的N段，将每一段**分别**映射到码集中的某个元素。然而这种方式有所缺陷：如果某段编码出错到一定程度，则这段信息就永远不可能恢复。如何避免呢？

一个基本的想法是，将一段中的信息重复存储到几个不同的编码中，这样即使某个编码严重出错，也可以依据另一些编码将这段信息复原。这种想法创造了卷积码：

![image-20220928182130212](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20220928182130212.png)

如上图所示，每段信息都被编入两个码字。上图中，若蓝色码字出错，粉色码字不会立刻丢失；通过利用蓝色和粉色码字间的相关性，它很有可能被恢复出来。

在介绍卷积码前，总结它的几个特点：

- 卷积码面向**信息流**编码，分组码面向**信息块**编码。
- 卷积码是将**相邻的多段信息**映射到一个码字，分组码将**一段信息**映射到一个码字。
- 在映射过程中，卷积码使用的映射方式**一致于**分组码的映射方式（此处为线性码）。

### 卷积编码

设一段信息长k个bit。按时间顺序，编码器会接收到如下信息：

**x~1~，x~2~，...，x~m~**

为将这m段信息（m个向量）映射到一个码字，编码器首先要做的是**存储**它们。编码器的存储部分结构如下：

**input(x)->D~1~->D~2~->...->D~m~**

不妨认为每个存储单元（**D**）由k个并联的D触发器组成。每个存储单元在时钟上升沿读取上一个存储单元的数据，**D~1~**从输入读数据。待**x~1~**到达最后的存储单元**D~m~**，存储情况为：

**x~m~，x~m-1~，...，x~1~**

编码器输出为一个n维编码向量**y**。为使这个编码来自所有m段信息，做如下操作：

- 每单元存储数据和input处的x分别生成自己的编码向量**y~i~=D~i~G~i~，y~0~=x~m+1~G~0~**，
- 将所有**y~i~**相加得到最后的**y**。

由于第一步中**D~i~**存储的是**x~m+1-i~**，**y**的求和表达式看起来像时间向量序列**x**和矩阵参数序列**G**做卷积，“卷积码‘’由此得名。

以下是模拟n=2,k=1,m=2时卷积编码器的代码（也叫(2,1,3)卷积码（最后一位为3是因为卷积序列长m+1，包括了input处的**x~m+1~**。）

```matlab
%信号序列长为10
n=10;
reg=zeros(1,2);%寄存器初始化
c=floor(rand(1,n)*2);
Ax=[1,0,1];
Ay=[1,1,1];
r=ones(1,2*n)*2;
r(1:2)=[c(1)*Ax(1),c(1)*Ay(1)];
for ii=2:length(c)
    reg(2)=reg(1);
    reg(1)=c(ii-1);
    state=[c(ii),reg];
    x=mod(sum(Ax.*state),2);
    y=mod(sum(Ay.*state),2);
    r(2*ii-1:2*ii)=[x,y];
end
```

