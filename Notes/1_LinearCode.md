## 纲要

编码比特数：对应信源信息量。即log2(可能发出的信息种类数)。

冗余度：如果发出的码长恰为编码比特数，则无冗余度。发出码长相对于编码比特数越长，则冗余度越大，鲁棒性也越高

编码的作用：编码实质是信源信息->某种符号组合的映射，这种符号组合应当适合信道传输。不同阶段的编码有不同的目标，如：

- 信源编码：用尽可能少的比特数尽可能准确（完整）体现要传递的信息。信源编码是之后一切信息传递的基础，若信源编码出错，之后无论如何编码也无法传递正确的信息。
- 信道编码：主要目的是对抗信道中的各种干扰，同时尽可能有效地利用信道资源（能量、带宽等）。为增加抗干扰能力，可能引入一定的冗余度。
- 安全编码：若编码的映射规则不被知晓，则接收方无法解读编码后的信息。安全编码尽可能隐藏这种映射规则，同时使加密和解密的过程尽可能简单。

## 线性码

### 离散信道模型

![image-20220922202024211](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20220922202024211.png)

上图为二元对称信道（BSC）：信道输入为0or1二元符号，输出也为0or1二元符号，出错的概率为p。

信道编码需求：

- 发现错误
- 纠正错误

以上的需求要求引入冗余度。

举个例子：如果只传2种信息0000和1111，而接收到的信息为0001。应用贝叶斯公式，
$$
P(x|y)=\frac{P(y|x)P(x)}{P(y)}
$$
在我们的例子中，“接收到0001”这个事件已经发生了，因此它应该是事件y，而在这个情况下判断原码更可能是0000还是1111，即判断P(原码是0000|接收到0001)以及P(原码是1111|接收到0001)的大小。

*此所谓最大后验推断。“后验”，即在某表象“已经发生了”的基础上，推测系统发生了怎样的变化。另外一种推断——最大似然推断，是先知道各系统变化情况下，某表象发生的概率大小（即P(y~i~|x~i~)）,当某表象发生时，找到最大的P(y~i~|x~i~)，并判断对应的x~i~发生。与最大后验推断相比，最大似然推断不需获取系统各变化情况发生的概率（P(x)），这也是其与最大后验推断的区别。若可以认定系统的各种变化发生的概率相等，则最大后验和最大似然两种推断没有区别。*

这个例子中，为简便起见不妨假设原码等概地取两个值。在p较小的情况下，错一个码的概率显然大于错三个码的概率，因此认定原码更可能是0000。这样我们就实现了检错功能。注意，原码集合的元素数为2^1^，而使用信道的次数（编码长度）却是2^4^，我们以3bit的冗余度换取了检错。

### 线性码

将上面这个简单的例子系统化，就得到线性码。顾名思义，线性码是线性组合出的码。（就二元信道而言，线性码中的线性运算是在模二域下进行的）下面展示如何引入冗余度，用n个bit表示k个bit。

**编码**

用n个bit传输信息，那么可能发送的信息为2^n^种。在这2^n^种信息中选择k种线性无关的信息张成k维线性空间。在模2运算的情况下，线性组合时每个信息的系数只有0和1两种，因此这个k维线性空间中容纳的信息种类数为2^k^。把系数组成向量，即实现了kbit信息到nbit信息的映射。用公式表示即
$$
\boldsymbol{c_0}=\sum_{i=0}^kd_i\boldsymbol{c_i}
$$
也即
$$
\boldsymbol{c_0}=\boldsymbol{dG}
$$


其中d是我们真正想表达的信息。

完成了冗余度的引入，接下来需要根据最大后验译码（由于我们认为各个原码发出的概率都是相等的，这里实际上相当于最大似然）。若我们发出了一个码**x**，由于信道的误差，接收到的码字是**y**=**x**+**e**，**e**代表”错误图案“。**e**的1-范数记为其码重w(**e**)。这里似然概率为
$$
p^{w(\boldsymbol{e})}(1-p)^{n-w(\boldsymbol{e})}
$$
在p不太大的情况下，显然错误图案越轻，似然概率越大，因而后验概率越大，可以根据得到的码字与可能发出的各种x（称为许用码字）之间的错误距离来进行判断和纠错。

由于这种判断方式依赖于相对于各种许用码字错误图案的码重，因此许用码字之间的距离与译码能力密切相关。依然举上面的例子，若许用码字集为0000和0011，接收到的码字为0001，这时就毫无区分能力了。容易得到，最大检错能力t和码字间的最小汉明距离d~f~间存在如下关系：
$$
t=\lfloor{\frac{d_f-1}{2}}\rfloor
$$
最小汉明距离为任意两个许用码字相减得到码的最小码重。由于线性码中两个许用码字相减得到的码还是许用码字，因此最小汉明距离显然就是最小许用码重。

**译码**

我们已经找到了2^k^个许用码字，也有了基于最大后验的判别方法，接下来只需确定错误图案，从获得的码字中减去它就可以了。不过，一个一个和许用码字对照显然太费时间。回忆一下，我们接收到的码字**y**可以表示为原码**x**和错误图案**e**的和，要找到e只需要消去x就可以了。如何消去呢？

**x**所在的许用码字集只用了n维空间中的k维。对于这个k维子空间**C**，必有一n-k维空间**H**与其正交，（注意**C**和**H**不一定互为正交补！）

*此处缺少一个证明*

因此可以利用这一点消除**x**。将**y**右乘**H^T^**，得到
$$
\boldsymbol{r}=\boldsymbol{yH^T}=\boldsymbol{xH^T}+\boldsymbol{eH^T}=\boldsymbol{eH^T}
$$
接下来反解出e即可。（课件上举的例子是观察法，不过更一般的方法应该还是模2域高斯消元）从y中减去e便得到原码**x**。

- 对于每个||e||~1~，有且仅有1个e是方程的解，则可以译码；
- 反之无法进行译码。
