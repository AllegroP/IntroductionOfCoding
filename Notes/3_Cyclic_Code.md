## 循环码

如我们之前的汇报（见第一次作业ppt），线性码的校正矩阵法虽然在一定程度上减少了时间和空间开销，但从绝对复杂度上来说还是很大。究其原因，是它的几个基选择太过随意，虽然互相线性独立，但也没有进一步的规律了。这就使得我们在译码的时候只能采用”瞎猫碰死耗子“的方法蛮力查表。循环码则解决了这个问题：

- 循环码是线性码
- 循环码中任意许用码字循环移位还是一个许用码字。

容易发现，只需要一个许用码字便可以生成循环码空间中的所有码（循环+线性组合），而传统线性码则要先指定m个基向量（m为原码长度）。这样好的码可以构造出来吗？我们很快会发现，不仅可以，循环码还带出了整个以抽象代数为基础的编码方法。

### 循环码的数学表示

首先我们要给循环一个合理的数学表示。当然，这之前我们要给循环的操作对象——序列一个合适的数学表示。多项式特别适合完成这个任务：

- 多项式天然适合乘法和除法（多项式乘法、除法已经研究得比较透彻）
- 多项式的每一位系数在计算时不会耦合。

*关于多项式当然还有卷积和z变换等等技巧。这些在本课中不会涉及，但也证明多项式是一种常用且有效的数学表示手段。*

向量**a**的多项式表示为：
$$
a=\sum_{i=0}^na_ix^{n-i}
$$
若**a**=[1,0,1,1]，则对应的多项式表示为x^3^+x+1。

现在表示循环：

以下恒等式成立：
$$
L(a)=(xa)mod(x^n-1)
$$
L表示左移。

直观地说，这是考虑到左移(乘x)时，由于位数的限制，原先的最高位被移出去了，同时又出现在现在的最低位，所以模去一个(x^n^-1)以去掉这部分偏差。

*注意这里已经用到了多项式除法*

因此k次位移可以表示为
$$
L_k(a)=(x^ka)mod(x^n-1)
$$
将这些位移再线性组合，得到一个循环码中，可以由a生成的的**所有**许用码字为：
$$
(A(x)a)mod(x^n-1)
$$
其中A(x)为x的多项式（次数不限，因为（x^n^a）mod(x^n^-1)就是(a)mod(x^n^-1)）

现在，这个码已经满足了

- 对循环封闭
- 对线性运算封闭

（在上面的两种运算后，码字的多项式表示仍然可以用上式表示）

本质上这是因为模f(f为多项式)对循环运算和线性运算是封闭的。

不过每次取模显然还是有点麻烦。能不能再简化呢？比如把取模化成加法、乘法？

### 欧几里得算法与循环码表示的简化

欧几里得算法的核心思想是：
$$
gcd(a,b)=Aa+Bb
$$
其中AB均为整数。即在整数范围中，a与b的最大公约数总能被a和b线性表出。

道理很好懂：既然a和b都是它们最大公约数的整数倍，那无论如何，它们线性组合出来的数都必然是它们最大公约数的整数倍。正因如此，mod(a,b)=k*gcd(a,b)也自然成立。

回到循环码的表示：
$$
(A(x)a)mod(x^n-1)
$$
显然，若令gcd(a,x^n^-1)=g(x)（这里的最大公因子指的是首位次数最高的多项式），那么A(x)a和x^n^-1必定有公因子g(x)；对于每一个A(x)，上式总可以表示为
$$
d(x)g(x)
$$
这也就是说，这样一个简短的式子所能表示的所有码字，恰好是一个循环码的码字空间！因此，给定g(x)，（需要满足g(x)|x^n^-1），一个循环码空间就完全确定了。g(x)称作循环码的**生成多项式**。

注意到，d(x)g(x)最高幂次为n-1，而若g(x)长k（最高幂次为k-1），那么d(x)最高幂次必然不超过n-k-1（长n-k），也就是说生成多项式同时决定了原码长度和编码长度的关系。

### 循环码的编码

最简单的编码就是让原码=d(x)然后直接和g(x)（生成多项式）相乘。如果我们还想让码字是系统码，我们可以让原码左移m位，在末尾添上校验位以便其能被g(x)整除（也就是，是循环码集的一部分），即
$$
c(x)=d(x)x^m+(-d(x)x^mmodg(x))
$$

### 循环码的解码

回到开始的问题——如何降低解码过程的复杂度？循环码的循环特性提供了一种可能的答案。

首先，每个循环码的许用码字都是g(x)的倍式。因此，将收到的码字模g(x)，便可分析出校正子：
$$
s(x)=r(x)mod(g(x))=(c(x)+e(x))mod(g(x))=e(x)mod(g(x))
$$
称e(x)对应的校正子是s(x)。

**利用循环特性缩小空间复杂度**：同一个错误图案经过循环移位后，产生的校正子**不同**。我们可以将同一个错误图案经移位后可能产生的校正子定义为一个集合，
$$
A_1,A_2,...,A_n
$$
并不需要存储全部的n个校正子。当译码时产生的校正子为A~i~ (i>1, i≤n)时，总可以将收到的码进行最多n次移位从而得到校正子A~1~。此时，对应的错误图案为e~1~；但这个错误图案是原错误图案移位而来的，因此还需要反向移位到原来的状态，以恢复原来的错误图案。**以上的过程中只需要存储A~1~及其对应的错误图案。**

相似地，对于每个这样的集合，我们只需要存储一个元素。

**特别地，**对于每个可检出的错误图案，也都有这样一个n元集合。在错误图案刚好在编码的末尾时，**其校正子恰好是自身**，因此**其自身必定在此n元集中**。对于这些错误图案，我们只需：

- 计算校正子；
- 检验错误图案的最高次幂；
- 若大于检错极限，循环位移并从第一步执行；
- 得到最高此幂在检错极限内的校正子并判定其为错误图案。

![image-20221011230805383](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221011230805383.png)

### 循环码的数学基础

经过上面的分析我们看到，生成多项式g(x)在循环码中发挥着重要的作用（直接决定循环码集）。因此，如何设计g(x)显得特别重要，而要解决这个问题，需要引入部分抽象代数的知识。

**素数模域**

任意素数p，有{0，1，...，p-1}在模p加乘下构成域GF(p)。

素数模域有一些良好的性质（域性质）：

- 定义了加法和乘法，并对它们封闭（线性的基础）
- 加法存在逆元（可理解为集合对减法封闭），乘法除加法恒等元（零元）外存在逆元（由欧几里得算法保证）；
- 加法、乘法满足交换律和结合律，乘法对于加法满足分配律。

素数模域中的一个重要定理是费马定理：

**对GF(p)中的任意a≠0，有a^p-1^=1(mod p)**

也就是说，GF(p)中的所有非零元恰是f(x)=x^p-1^-1的所有根。也即**在GF(p)上**，
$$
x^{p-1}-1=\prod_{i}^{p-1}(x-i)
$$
