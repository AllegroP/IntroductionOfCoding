## 循环码

如我们之前的汇报（见第一次作业ppt），线性码的校正矩阵法虽然在一定程度上减少了时间和空间开销，但从绝对复杂度上来说还是很大。究其原因，是它的几个基选择太过随意，虽然互相线性独立，但也没有进一步的规律了。这就使得我们在译码的时候只能采用”瞎猫碰死耗子“的方法蛮力查表。循环码则解决了这个问题：

- 循环码是线性码
- 循环码中任意许用码字循环移位还是一个许用码字。

容易发现，只需要一个许用码字便可以生成循环码空间中的所有码（循环+线性组合），而传统线性码则要先指定m个基向量（m为原码长度）。这样好的码可以构造出来吗？我们很快会发现，不仅可以，循环码还带出了整个以抽象代数为基础的编码方法。

### 循环码的数学表示

首先我们要给循环一个合理的数学表示。当然，这之前我们要给循环的操作对象——序列一个合适的数学表示。多项式特别适合完成这个任务：

- 多项式天然适合乘法和除法（多项式乘法、除法已经研究得比较透彻）
- 多项式的每一位系数在计算时不会耦合。

*关于多项式当然还有卷积和z变换等等技巧。这些在本课中不会涉及，但也证明多项式是一种常用且有效的数学表示手段。*

向量**a**的多项式表示为：
$$
a=\sum_{i=0}^na_ix^{n-i}
$$
若**a**=[1,0,1,1]，则对应的多项式表示为x^3^+x+1。

现在表示循环：

以下恒等式成立：
$$
L(a)=(xa)mod(x^n-1)
$$
L表示左移。

直观地说，这是考虑到左移(乘x)时，由于位数的限制，原先的最高位被移出去了，同时又出现在现在的最低位，所以模去一个(x^n^-1)以去掉这部分偏差。

*注意这里已经用到了多项式除法*

因此k次位移可以表示为
$$
L_k(a)=(x^ka)mod(x^n-1)
$$
将这些位移再线性组合，得到一个循环码中，可以由a生成的的**所有**许用码字为：
$$
(A(x)a)mod(x^n-1)
$$
其中A(x)为x的多项式（次数不限，因为（x^n^a）mod(x^n^-1)就是(a)mod(x^n^-1)）

现在，这个码已经满足了

- 对循环封闭
- 对线性运算封闭

（在上面的两种运算后，码字的多项式表示仍然可以用上式表示）

本质上这是因为模f(f为多项式)对循环运算和线性运算是封闭的。

不过每次取模显然还是有点麻烦。能不能再简化呢？比如把取模化成加法、乘法？

### 欧几里得算法与循环码表示的简化

欧几里得算法的核心思想是：
$$
gcd(a,b)=Aa+Bb
$$
其中AB均为整数。即在整数范围中，a与b的最大公约数总能被a和b线性表出。

道理很好懂：既然a和b都是它们最大公约数的整数倍，那无论如何，它们线性组合出来的数都必然是它们最大公约数的整数倍。正因如此，mod(a,b)=k*gcd(a,b)也自然成立。

回到循环码的表示：
$$
(A(x)a)mod(x^n-1)
$$
显然，若令gcd(a,x^n^-1)=g(x)（这里的最大公因子指的是首位次数最高的多项式），那么A(x)a和x^n^-1必定有公因子g(x)；对于每一个A(x)，上式总可以表示为
$$
d(x)g(x)
$$
这也就是说，这样一个简短的式子所能表示的所有码字，恰好是一个循环码的码字空间！因此，给定g(x)，（需要满足g(x)|x^n^-1），一个循环码空间就完全确定了。g(x)称作循环码的**生成多项式**。

注意到，d(x)g(x)最高幂次为n-1，而若g(x)长k（最高幂次为k-1），那么d(x)最高幂次必然不超过n-k-1（长n-k），也就是说生成多项式同时决定了原码长度和编码长度的关系。

### 循环码的编码

最简单的编码就是让原码=d(x)然后直接和g(x)（生成多项式）相乘。如果我们还想让码字是系统码，我们可以让原码左移m位，在末尾添上校验位以便其能被g(x)整除（也就是，是循环码集的一部分），即
$$
c(x)=d(x)x^m+(-d(x)x^mmodg(x))
$$

### 循环码的解码

回到开始的问题——如何降低解码过程的复杂度？循环码的循环特性提供了一种可能的答案。

首先，每个循环码的许用码字都是g(x)的倍式。因此，将收到的码字模g(x)，便可分析出校正子：
$$
s(x)=r(x)mod(g(x))=(c(x)+e(x))mod(g(x))=e(x)mod(g(x))
$$
称e(x)对应的校正子是s(x)。

**利用循环特性缩小空间复杂度**：同一个错误图案经过循环移位后，产生的校正子**不同**。我们可以将同一个错误图案经移位后可能产生的校正子定义为一个集合，
$$
A_1,A_2,...,A_n
$$
并不需要存储全部的n个校正子。当译码时产生的校正子为A~i~ (i>1, i≤n)时，总可以将收到的码进行最多n次移位从而得到校正子A~1~。此时，对应的错误图案为e~1~；但这个错误图案是原错误图案移位而来的，因此还需要反向移位到原来的状态，以恢复原来的错误图案。**以上的过程中只需要存储A~1~及其对应的错误图案。**

相似地，对于每个这样的集合，我们只需要存储一个元素。

**特别地，**对于每个可检出的错误图案，也都有这样一个n元集合。在错误图案刚好在编码的末尾时，**其校正子恰好是自身**，因此**其自身必定在此n元集中**。对于这些错误图案，我们只需：

- 计算校正子；
- 检验错误图案的最高次幂；
- 若大于检错极限，循环位移并从第一步执行；
- 得到最高此幂在检错极限内的校正子并判定其为错误图案。

![image-20221011230805383](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221011230805383.png)

### 循环码的数学基础

经过上面的分析我们看到，生成多项式g(x)在循环码中发挥着重要的作用（直接决定循环码集）。因此，如何设计g(x)显得特别重要，而要解决这个问题，需要引入部分抽象代数的知识。

**素数模域**

任意素数p，有{0，1，...，p-1}在模p加乘下构成域GF(p)。

素数模域有一些良好的性质（域性质）：

- 定义了加法和乘法，并对它们封闭（线性的基础）
- 加法存在逆元（可理解为集合对减法封闭），乘法除加法恒等元（零元）外存在逆元（由欧几里得算法保证）；
- 加法、乘法满足交换律和结合律，乘法对于加法满足分配律。

素数模域中的一个重要定理是费马定理：

**对GF(p)中的任意a≠0，有a^p-1^=1(mod p)**

也就是说，GF(p)中的所有非零元恰是f(x)=x^p-1^-1的所有根。也即**在GF(p)上**，
$$
x^{p-1}-1=\prod_{i}^{p-1}(x-i)
$$
另一个结论是，对GF(p)中的任意a≠0，存在n使得a^n^=1(mod p)。n有可能等于p-1，也可能是**p-1的因子**；对于每个a，满足条件的最小n为a在GF(p)的级，级为p-1的a为GF(p)的本原元。

对于本原元，其0次方、1次方....p-2次方各不相同，恰巧遍历了GF(p)中的所有元素。因此可以用本原元的p-1个不同次幂表示所有的非零元。也即
$$
x^{p-1}-1=\prod_{i}^{p-1}(x-a^i)
$$

在GF(p)上定义多项式f(x)（即实数域上的f(x)mod(p))，（当然它的所有系数都属于GF(p)）则若w是f(x)的根，则w的p次幂也是f(x)的根。由此就产生了w的一组根：
$$
w,w^{p^1},w^{p^2},... ,w^{p^n}
$$
这些数里有一些两两相同。但存在正整数m使得
$$
w,w^{p^1},w^{p^2},... ,w^{p^{m-1}}
$$
各不相同，以上的根组成了一组共轭根系。

不过，这些根可未必在GF(p)内。为了找到这些根，需要设计扩域。

### 扩域和生成多项式的根

虽然我们讲了很多素数域的知识，但我们并不打算在素数域上操作，之所以介绍素数域是因为，接下来我们要介绍的扩域保留了素数域的全部良好性质，并且有助于找到生成多项式的根。

生成多项式可以表示成下列形式：
$$
\sum_{i=0}^{m}a_ix^{m-i}
$$
生成多项式最多m+1项，且所有系数均在GF(p)中。不过就像实数域系数数字滤波器的极点不在实数域上，生成多项式的根也不在GF(p)中，而在GF(p^m^)中，GF(p^m^)即为所谓**扩域**，它由最长m位的**序列**组成，其中的乘法被替换为序列乘法（**卷积**）。

类比素数域，要构造GF(p^m^)，首先要确定p,m和不可约多项式（类比于素数域里的素数）。素数域的素数不在素数域中，同理不可约多项式也不在扩域中，它的次数是m，比扩域中的所有多项式高1。不可约多项式确定之后，最高次幂比它低的所有多项式都在扩域中，共p^m^个。

下面是构造GF(2^2^)的例子：

![image-20221012191243382](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221012191243382.png)

![image-20221012191254495](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221012191254495.png)

我们将构造完的GF(p^m^)和原素数域GF(p)对比：

- 非零元个数为p^m^-1
- 所有非零元的级都是p^m^-1的因子
- 级为p^m^-1的元素为本原元
- 所有非零元素可被本原元n次幂表出

在扩域中，多项式根的问题得到了解决。找到了多项式的一个根，便可以找到它的一组共轭根系；同样若要使某个多项式的根包含一个我们想要的“好”根，则这个多项式的根同时也要包含所有“好“根的共轭根。满足此条件的幂次最小的多项式，即为所有$ x-w^{p^n} $相乘。由这种方法，我们也可以构造性质良好的生成多项式了。

![image-20221012195526542](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221012195526542.png)

![image-20221012195538599](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221012195538599.png)

![image-20221012195550913](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221012195550913.png)

最后一张图中的结论十分重要。回顾逻辑链条：

最高次幂为m的不可约多项式在GF(p)上没有根，它的根全在扩域GF(p^m^)中；

扩域GF(p^m^)上的元素可以由本原元的整数次幂表示；

扩域上的元素均为x^m-1^-1的根；

这些根分为几组共轭根系，共轭根系可以由本原元的幂次不断乘p找到。共轭根系中的元素拥有相同的级。任何一个系数出自GF(p)的多项式的根要么包括一个共轭根系中的所有元素，要么都不包括。所有根都在同一个共轭根系中的多项式成为这个共轭根系的最小多项式。所有最小多项式的乘积为$ x^{p^m-1}-1$。

下面开始设计码字：

**应用1**

对于一个生成多项式g(x)，其周期为满足$ g(x)|x^k-1$的最小整数k。不难证明k为g(x)所有根的级的最小公倍数。

（称作周期是因为，如果用[1,0,0,0,0,0,....]对应的多项式除g(x)，商的循环长度就是k）

特殊地，定义本原多项式为以本原元为根的多项式，那么其周期为p^m^-1。

对于(n,k)循环码，生成多项式g(x)的最高次幂为m=n-k，且由循环码的构造方法，g(x)以n为周期（不一定是最小周期），也就是说，码长n是周期的整数倍。若n不是最小周期（n=aN），则错误图案平移N位后得到的校正子相同。因此在设计生成多项式时就要严格选择共轭根系，避免踩到不适合的N上。

**应用2**

由于每个许用码字必为生成多项式的倍式，因此可以将生成多项式的根代入码字检验其是否为许用码字。（每个共轭根式中出一个根代入检验即可，因为如果这个根是码字的根，则其他根也是）

**应用3**

生成多项式有重根的码性能一般要比没有重根的码差。（之前没有讨论过重根问题）对于GF(2)，选择的码长n最好为奇数，原因见下：

![image-20221101003157946](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221101003157946.png)

**应用4**

BCH码：

![image-20221101003232076](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221101003232076.png)、

只要选取α为本原元，则n就是确定的。这样说来，是不是我们随意选取连续几个α的整数次幂就可以了呢？并不是。生成多项式的根必须包含整个共轭根系，而每多一个根，最高幂次就上升一位，而由于生成多项式长度为n-k，n不变的情况下k必定减小，降低了编码效率。因此应该谨慎选择连续的幂次，使得其中涉及的共轭根系尽可能少。

**应用5**

RS码：

BCH码为了引入连续的幂次根，往往不得不连带引入其共轭根。如果没有这些共轭根，则编码效率还会进一步提高。如果每个共轭根系只有一个元素，那么就将编码效率提高到极致了。这就是RS码。

为了达到每个共轭根系只有一个元素的目标，RS码生成多项式的系数全在GF(p)中。这样，在p元域上就可以达到(n,k,n-k+1)码，实现最高效率。

以8元域为例：（注意GF(8)就是GF(2^3^)，应当找到一个3次不可约多项式来构建该域。在整数域是无法构建GF(8)的，因为8不是素数。此时生成多项式的系数应当是2次多项式，即长度为3的二元序列）

![image-20221101094707975](C:\Users\张鹤龄\AppData\Roaming\Typora\typora-user-images\image-20221101094707975.png)

构建完生成多项式，为了使用方便，接下来将RS码化为系统码。循环码也是一种线性码，因此也有对应的生成矩阵；只要让生成矩阵中的所有行向量全为生成多项式的倍式，则线性码就变成循环码。要构建系统码则要构建形如$[I| G]$的矩阵，因此设生成多项式的最高次幂为m，循环码长为n，生成矩阵形如：
$$
[x^{n-1}-x^{n-1}mod(g(x))]\\
[x^{n-2}-x^{n-2}mod(g(x))]\\
...\\
[x^{m}-x^{m}mod(g(x))]
$$
RS码现在有c~0~c~1~c~2~.....c~m-1~的形式，每个c都是一个长3的二元序列。RS码的自由距为n-k，可以纠$\lfloor\frac{n-k}{2}\rfloor-1$个错。但这个错是在c意义上的，因此RS码比较擅长应对集中出现的错误，而对随机出现的错误能力一般。这个特点决定了它可以配合卷积码使用：在卷积编码前加一次RS码，卷积译码之后加一次RS译码，则可以较好地对抗卷积码集中出错的缺点。

